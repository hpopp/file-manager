# DNS-based discovery: all nodes share a network alias that resolves to all container IPs.
# No need to list peers explicitly â€” each node discovers the others via DNS.
#
# Kubernetes equivalent: create a headless Service and set
#   DISCOVERY_DNS_NAME to the service FQDN.

x-common-env: &common-env
  BIND_ADDRESS: "0.0.0.0:8080"
  DATA_DIR: /data
  DISCOVERY_DNS_NAME: file-manager
  RUST_LOG: file_manager=debug
  STORAGE_BACKEND: local
  LOCAL_STORAGE_PATH: /files
  TEST_MODE: "true"

x-common: &common
  build:
    context: .
    args:
      CREATED: "${CREATED:-}"
      VERSION: "${VERSION:-0.1.0}"
  networks:
    file-network:
      aliases:
        - file-manager
  healthcheck:
    test: ["CMD", "curl", "-f", "http://localhost:8080/_internal/health"]
    interval: 5s
    timeout: 3s
    retries: 3
    start_period: 10s

services:
  node-1:
    <<: *common
    container_name: file-manager-node-1
    environment:
      <<: *common-env
      NODE_ID: node-1
    ports:
      - "8080:8080"
    volumes:
      - node1-data:/data
      - node1-files:/files

  node-2:
    <<: *common
    container_name: file-manager-node-2
    environment:
      <<: *common-env
      NODE_ID: node-2
    ports:
      - "8081:8080"
    volumes:
      - node2-data:/data
      - node2-files:/files

  node-3:
    <<: *common
    container_name: file-manager-node-3
    environment:
      <<: *common-env
      NODE_ID: node-3
    ports:
      - "8082:8080"
    volumes:
      - node3-data:/data
      - node3-files:/files

volumes:
  node1-data:
  node1-files:
  node2-data:
  node2-files:
  node3-data:
  node3-files:

networks:
  file-network:
    driver: bridge
